#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define NUM_REGISTERS (16)
unsigned char registers[16];
#define MEMORY_SIZE (256*256)
unsigned char memory[MEMORY_SIZE];
unsigned int PC;

#define TEST_PROGRAM_SIZE (128)
typedef struct
{
	const char program[TEST_PROGRAM_SIZE];
	int exit_code;
} Test;

#define NUM_TESTS (23)
Test tests[NUM_TESTS] = {
	{{0x00,0x00, 0xe0,0x00}, 0x00}, // can exit
	{{0x00,0x01, 0xe0,0x00}, 0x01}, // can exit with non-zero code
	{{0x0f,0x05, 0xef,0x00}, 0x05}, // can use higher register
	{{0x00,0x04, 0x01,0x05, 0x10,0x01, 0xe0,0x00}, 0x09}, // add two values
	{{0x00,0xf0, 0x01,0xf2, 0x10,0x01, 0xe0,0x00}, 0xe2}, // add two high values
	{{0x00,0x05, 0x01,0x03, 0x20,0x01, 0xe0,0x00}, 0x02}, // sub
	{{0x00,0x05, 0x01,0x03, 0x20,0x10, 0xe0,0x00}, 0xfe}, // sub larger from smaller
	{{0x00,0x04, 0x01,0x05, 0x02,0x10, 0x10,0x01, 0xa2,0x00, 0xe2,0x00}, 0x10}, // add two low values, check overflow
	{{0x00,0xf0, 0x01,0xf2, 0x02,0x10, 0x10,0x01, 0xa2,0x00, 0xe2,0x00}, 0x11}, // add two high values, check overflow
	{{0x00,0x05, 0x01,0x03, 0x02,0x07, 0x20,0x01, 0xa2,0x00, 0xe2,0x00}, 0x07}, // sub without overflow
	{{0x00,0x05, 0x01,0x03, 0x02,0x07, 0x20,0x10, 0xa2,0x00, 0xe2,0x00}, 0x06}, // sub with overflow
	{{0x00,0x14, 0x01,0x25, 0x30,0x01, 0xe0,0x00}, 0x04}, // and
	{{0x00,0x14, 0x01,0x25, 0x40,0x01, 0xe0,0x00}, 0x35}, // or
	{{0x00,0x15, 0x01,0x14, 0x50,0x01, 0xe0,0x00}, 0x01}, // is greater
	{{0x00,0x15, 0x01,0x15, 0x50,0x01, 0xe0,0x00}, 0x00}, // isn't greater
	{{0x01,0x00, 0x02,0x08, 0x60,0x12, 0xe0,0x00, /*data*/ 0xfe}, 0xfe}, // lod memory
	{{0x00,0xef, 0x01,0xcc, 0x02,0xaa, 0x70,0x12, 0x63,0x12, 0xe3,0x00}, 0xef}, // sav then lod high mem page
	{{0x00,0x00, 0x01,0x08, 0x80,0x01, 0xe0,0x00, 0xe1,0x00}, 0x08}, // jmp over a halt
	{{0x00,0x00, 0x01,0xaa, 0x90,0x00, 0xe0,0x00, 0xe1,0x00}, 0xaa}, // cnd
	{{0x00,0x01, 0x01,0xaa, 0x90,0x00, 0xe0,0x00, 0xe1,0x00}, 0x01}, // not cnd
	{{0x00,0x00, 0x01, 'P', 0xB1,0x00, 0xe0,0x00}, 0x00}, // pnt
	{{0x00,0x00, 0x01,0x0f, 0x02,0x00, 0x03,0x0a, 0x04,0x01, 0x10,0x01, 0x21,0x14, 0x91,0x00, 0x80,0x23, 0xe0,0x00}, 0x78}, // calculate 15th tri number
	{{0x00,0xff, 0x01,0xff, 0x02,0xff, 0x03,0x01, 0x04,0x00, 0x05,0x0c, 0x20,0x03, 0xa1,0x00, 0xa2,0x00, 0x92,0x00, 0x80,0x45, 0xe2,0x00}, 0x00}, // stress test 0xff*0xff*0xff loops
};

inline int memory_location(int a, int b)
{
	return (a<<8)+b;
}

unsigned char run()
{
	int running = 1;
	unsigned char exit_code = 0;
	PC = 0;
	int overflow=0;
	while(running)
	{
		unsigned char instruction = (memory[PC]&0xf0) >> 4;
		int d = memory[PC]&0x0f;
		int a = (memory[PC+1]&0xf0) >> 4;
		int b = memory[PC+1]&0x0f;
		int v = memory[PC+1];
		int new_overflow = 0;
		switch(instruction)
		{
			case 0x0: // VAL
				registers[d] = v;
				break;
			case 0x1: // ADD
				if(0xff-registers[b] < registers[a])
					new_overflow = 1;
				registers[d] = registers[a] + registers[b];
				break;
			case 0x2: // SUB
				if(registers[b] > registers[a])
					new_overflow = -1;
				registers[d] = registers[a] - registers[b];
				break;
			case 0x3: // AND
				registers[d] = registers[a] & registers[b];
				break;
			case 0x4: // OR
				registers[d] = registers[a] | registers[b];
				break;
			case 0x5: // GTE
				registers[d] = registers[a] > registers[b];
				break;
			case 0x6: // LOD
				registers[d] = memory[memory_location(registers[a],registers[b])];
				break;
			case 0x7: // SAV
				memory[memory_location(registers[a],registers[b])] = registers[d];
				break;
			case 0x8: // JMP
				PC = memory_location(registers[a], registers[b]);
				break;
			case 0x9: // CND
				if(!registers[d])
					PC += 2;
			case 0xa: // OVR
				if(overflow > 0 && registers[d] == 0xff)
					new_overflow = 1;
				if(overflow < 0 && registers[d] == 0x00)
					new_overflow = -1;
				registers[d]+=overflow;
				break;
			case 0xb: // PNT
				putchar(registers[d]);
				break;
			case 0xe: // HLT
				exit_code = registers[d];
				running = 0;
				break;
			default:
				printf("\nInvalid instruction 0x%x", instruction);
				exit_code = 0xff;
				running = 0;
				break;
		}
		overflow = new_overflow;
		if(instruction != 0x8)
			PC += 2;
	}
	return exit_code;
}

int run_test(int n)
{
	memcpy ( memory, tests[n].program, TEST_PROGRAM_SIZE );
	unsigned char exit_code = run();
	if(exit_code == tests[n].exit_code)
	{
		printf("P");
		return 0;
	}
	else
	{
		printf("\nTEST %d FAILED: Expected exit_code 0x%x got 0x%x", n, tests[n].exit_code, exit_code);
		return 1;
	}
}

void corrupt_memory()
{
	printf("\nFilling memory with values.");
	int i;
	srand(0);
	for(i=0; i<MEMORY_SIZE; i++)
		memory[i] = rand();
	for(i=0; i<NUM_REGISTERS; i++)
		registers[i] = rand();
}

int main( int arg, const char** argv)
{
	corrupt_memory();

	printf( "\nRunning Tests: " );

	int i;
	int fail = 0;
	for(i=0; i<NUM_TESTS&&!fail; i++)
		fail = run_test(i);
	if(fail)
		printf("\n\nSome tests failed!");
	else
		printf("\n\nAll tests passed :)\n");
	return fail;
}