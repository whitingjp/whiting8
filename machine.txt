All 8 bit.
16 registers (4 bits)
instructions are 16 bit
1st 4 is opcode
2nd 4 is 'dest' D

3rd 4 is 'src' A
4th 4 is 'src' B
  OR
final 8 are 'value' V

0 VAL V -> D
1 ADD D+V -> D
2 SUB D-V -> D
3 AND A&B -> D
4 OR  A|B -> D
5 GT  A>=B -> D
6 LOD Load memory addressed by AB into D
7 SAV Save D into memory addressed by AB
8 JMP Set PC to memory addressed by AB.
9 CND Skip next instruction if D==0
A OVR Add (or take) one from V if last operation caused arithmetic overflow.
B PNT Print D as ascii char to console
C DSP Start displaying memory addressed from AB pallete chosen from 16 possibles via D, waits for VSYNC
D INP Load input mask into D  (input bits are NESWAB00)
E HLT Quit with exit code D
F SND To Be Designed (presumably point at a filled buffer and play in some way)

Memory layout is free.
'VRAM' is 128x128 2 bit pixels = 4096 bytes = 16 memory pages
So 64x2 (back buffer) = 32 pages of visual mem.
Remaining 224 pages for code + assets.


;mem copy
VAL 1 $srca
VAL 2 $srcb
VAL 3 $dsta
VAL 4 $dstb
VAL 5 $n
VAL 6 1
:JUMP
LOD 0 1 2
SAV 0 3 4
SUB 5 6
ADD 1 6
OVR 2
ADD 3 6
OVR 4
CND 5
JMP :JUMP


;print string
VAL 1 $srca
VAL 2 $srcb
VAL 3 1
:LOOP
LOD 0 1 2
CND 0
JMP :CONTINUE
JMP :END
PNT 0
ADD 1 3
OVR 2
:END
